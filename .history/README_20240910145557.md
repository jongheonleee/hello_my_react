# Hello My React 🙋🏻‍♂️

<br>

## 📌 01. 리액트의 등장 배경 및 기본 개념 


#### 🧑🏻‍🏫 주요 내용 작성 

<img src="" width="800" height="500"/>
(오늘 내용 정리해서 올리기)

#### 👉 '지속적으로 데이터가 변화하는 대규모 애플리케이션을 위한 뷰(view) 전용 라이브러리'

> - 대규모 애플리케이션을 기준으로 '템플릿'의 문제점은 데이터 변동에 따라 성능이 매우 느림. 데이터 변경에 따라 웹 브라우저가 css 다시 연산, 레이아웃 구성, 리페인팅 작업을 처리함 
> - 리액트는 '기존의 뷰는 날리고 처음부터 해당 부분만 새로 렌더링함. 즉, 데이터 변경이 발생됨에 따라 기존에 있던 것을 버리고 정해진 규칙에 따라 리렌더링함'

<br>

#### 👉 가장 기본 단위인 '컴포넌트'

> - 컴포넌트란? '뷰의 모습과 동작 방식을 정의해 놓음', '단순한 문자열(HTML)이 아닌 재사용 가능한 API로 수많은 기능을 내장하고 있음'
> - 리액트는 컴포넌트의 조합으로 화면을 구성하는 방식임 
> - render 함수를 통해서 특정 컴포넌트의 '모습'과 '동작' 방식을 정의하고 반환함(컴포넌트를 반환함) 

<br>

#### 👉 Virtual DOM을 사용하는 이유?

> - DOM? 'Document Object Model의 객체로 문서 구조를 트리 형식으로 표현한 방법, 트리 연산을 적용할 수 있음(삽입, 삭제, 수정, 조회)
> - 기존의 문제점은 DOM의 비효율적인 작업 처리
> - 기존의 DOM 동작 방식, 데이터 변경 발생하면 웹 브라우저가 CSS 재연산, 레이아웃 재구성, 리페인팅 작업을 처리함
> - 이를 최적화하기 위한 방법으로 Virtual DOM을 사용하여 'DOM을 최소한으로 조작하여 작업을 처리함'
> - 리액트는 Virtual DOM 방식을 통해 DOM 업데이트를 추상화함으로써 DOM 처리 횟수를 최소화함

<br>

#### 👉 데이터 변경에 따른 동작 방식

> - (1) 전체 UI를 Virtual DOM에 리렌더링함
> - (2) 실제 DOM과 Virtual DOM을 비교함
> - (3) 변경된 부분만 실제 DOM에 적용함 

<br>
<br>

## 📌 01. JSX란? 


#### 🧑🏻‍🏫 주요 내용 작성 

<img src="" width="800" height="500"/>
(오늘 내용 정리해서 올리기)

#### 👉 번들러란? 

> - 번들은 '묶는다'를 의미함. 따라서, 번들러는 '파일을 묶듯이 연결하는 것'을 의미함
> - 브라우저에는 import 기능과 같이 모듈을 불러오는 기능이 존재하지 않음. Node.js에서 지원하는 기능임

<br>

#### 👉 JSX란? 

#### 01. JSX 대표 예시 코드 
```javascript
import React from 'react';
import logo from './logo.svg';
import './App.css';

function App() {
  return (
    <div className="App">
      <header className="App-header">
        <img src={logo} className="App-logo" alt="logo" />
        <p>
          Edit <code>src/App.js</code> and save to reload.
        </p>
        <a
          className="App-link"
          href="https://reactjs.org"
          target="_blank"
          rel="noopener noreferrer"
        >
          Learn React
        </a>
      </header>
    </div>
  );
}

export default App;

```

#### 02. JSX가 자바스크립트 형태의 코드로 변환되는 방법


```javascript

// JSX 코드 
import React from 'react';

function App() {
  return (
    <div>
      <h1>Hello, React!</h1>
      <p>This is a simple JSX example.</p>
    </div>
  );
}

export default App;

// 변환된 자바스크립트 코드
import React from 'react';

function App() {
  return React.createElement(
    'div', 
    null, 
    React.createElement('h1', null, 'Hello, React!'),
    React.createElement('p', null, 'This is a simple JSX example.')
  );
}

export default App;


```

> - 위에 코드가 JSX임. 일반적인 문자열 형태의 HTML이 아니고 문자열 템플릿도 아님
> - 자바스크립트의 확장 문법임, 브라우저에서 실행되기 전에 코드가 번들링(임포트)되는 과정에서 바벨을 사용하여 일반 자바스크립트 형태로 변환됨(02 코드 참고) 


<br>

#### 👉 JSX에서 주의해야할 사항

> - 리액트 컴포넌트에서 요소 여러 개를 하나의 요소로 반드시 감싸야함 
> - Virtual DOM에서 컴포넌트 변화를 탐지할 때 효율적으로 비교할 수 있도록 컴포넌트 내부는 하나의 DOM 트리 구조로 이루어져야 함(규칙)
> - 자바스크립트 표현식을 작성하려면 JSX 내부에서 코드를 {}로 감싸면됨 




## 8장. Hooks

### 📌 Hook?

> - Hook을 사용하면 클래스형 컴포넌트를 사용하지 않고도 대부분의 기능을 구현할 수 있음. (뭔가 파이써의 ABC 추상 인터페이스 느낌임. 사용자가 굳이 만들어서 쓰는 것이 아니라 가져다가 사용해라)
> - 프로젝트 개발할 때, 함수 컴포넌트의 사용을 첫 번째 옵션으로 두고 꼭 필요한 상황에서만 클래스형 컴포넌트를 구현

### 📌 Hook의 종류

1. useState : 함수 컴포넌트에서 가변적인 상태(iv)를 지닐 수 있게 해줌
    - (1) 상태값 : 초기값 설정
    - (2) 상태를 변경하는 함수 : 해당 iv를 변경하는 함수 
    - 한가지 상태에 대해서만 정의, 즉 여러개의 iv를 다루고 싶으면 그 만큼 만들어야함 

2. useEffect : 렌더링 이후 특정 작업처리(추가 가공)
    

3. useReducer : 다영한 컴포넌트 상황에 따라 다양한 상태를 다른 값으로 업데이트 할 때 사용
    - 리듀스? '자바 스트림의 reduce()와 동일한 개념, 현재 상태(state), 액션(action, 특정 경우) 값을 전달받아 새로운 상태를 반환하는 함수'

4. useMemo : 렌더링 과정에서 특정 값이 바뀌었을 때만 연산을 실행, 원하는 값이 변경되지 않았다면 이전에 연산했던 결과를 재사용(최적화)

5. useCallback : 렌더링 성능을 최적화하는 상황에서 사용, 함수를 재사용할 수 있음
    - (1) 생성하고 싶은 함수
    - (2) 배열(배열에는 어떤 값이 변경될 때 함수를 새로 생성해야하는지 명시함)

6. useRef : 함수 컴포넌트에서 ref를 쉽게 사용할 수 있도록 도와줌


### 📌 커스텀 Hooks 할용

- 여러 컴포넌트에서 비슷한 기능을 공유할 경우, 이를 커스텀해서 새로운 Hook으로 작성하여 로직을 재활용 할 수 있음
- 약간, 자바로 따지면 클래스 상속이나 Template Method 패턴과 같은 느낌
- 컴포넌트는 여러개로 조합해서 사용할 수 있음. 이 점을 잘 인지해야함


